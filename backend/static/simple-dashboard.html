<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Monitor Dashboard</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

  <!-- D3.js for network topology visualization -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Modern Dashboard CSS -->
  <link rel="stylesheet" href="/static/dashboard-modern.css">
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-primary);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border-color);
    }

    .header h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      color: var(--primary-color);
    }

    .card-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .card {
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .card-title {
      font-size: 16px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      font-weight: 500;
    }

    .card-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .blue { color: var(--primary-color); }
    .green { color: var(--secondary-color); }
    .purple { color: var(--accent-color); }

    button {
      padding: 8px 12px;
      border-radius: var(--border-radius);
      border: none;
      background-color: var(--primary-color);
      color: white;
      font-size: 14px;
      cursor: pointer;
    }

    button:hover {
      opacity: 0.9;
    }

    /* Status message styling */
    .status-message {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
      padding: 15px;
      border-radius: var(--border-radius);
      background-color: #e0f2fe;
      color: #0369a1;
      border: 1px solid #7dd3fc;
      box-shadow: var(--shadow);
      animation: slide-in-top 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
      position: relative;
      overflow: hidden;
    }

    .status-message::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background-color: #0369a1;
    }

    .status-message.success {
      background-color: #dcfce7;
      color: #166534;
      border-color: #86efac;
    }

    .status-message.success::before {
      background-color: #166534;
    }

    .status-message.error {
      background-color: #fee2e2;
      color: #b91c1c;
      border-color: #fca5a5;
    }

    .status-message.error::before {
      background-color: #b91c1c;
    }

    .status-message button {
      margin-left: auto;
      background: none;
      border: none;
      color: currentColor;
      cursor: pointer;
      padding: 5px;
      border-radius: 50%;
      transition: all var(--transition-fast);
    }

    .status-message button:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: rotate(90deg);
    }

    @keyframes slide-in-top {
      0% {
        transform: translateY(-20px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    #status {
      margin-top: 20px;
      padding: 10px;
      border-radius: var(--border-radius);
      background-color: var(--card-background);
      box-shadow: var(--shadow);
      display: none;
    }

    .success {
      color: var(--secondary-color);
    }

    .error {
      color: #ef4444;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1><i class="fas fa-network-wired"></i> Network Monitor Dashboard</h1>
      <div class="controls">
        <select id="timeRange">
          <option value="5m">Last 5 minutes</option>
          <option value="15m" selected>Last 15 minutes</option>
          <option value="30m">Last 30 minutes</option>
          <option value="1h">Last hour</option>
          <option value="6h">Last 6 hours</option>
          <option value="24h">Last 24 hours</option>
        </select>
        <button id="fetchData"><i class="fas fa-sync-alt"></i> Refresh Data</button>
        <button id="exportDataBtn"><i class="fas fa-download"></i> Export Data</button>
        <button id="darkModeToggle" class="theme-toggle"><i class="fas fa-moon"></i></button>
        <div id="refreshIndicator" class="refresh-indicator">
          <div class="refresh-spinner"></div>
          <span>Updating...</span>
        </div>
      </div>
    </div>

    <!-- Status message (hidden by default) -->
    <div id="statusMessage" class="status-message" style="display: none;">
      <i class="fas fa-info-circle"></i>
      <span id="statusText"></span>
      <button id="dismissStatus"><i class="fas fa-times"></i></button>
    </div>

    <div class="card-container" id="metrics">
      <div class="card">
        <div class="card-title"><i class="fas fa-arrow-down"></i> Incoming Traffic</div>
        <div class="card-value loading" id="incomingTraffic">Loading...</div>
        <div class="card-subtitle">Network download speed</div>
      </div>
      <div class="card">
        <div class="card-title"><i class="fas fa-arrow-up"></i> Outgoing Traffic</div>
        <div class="card-value loading" id="outgoingTraffic">Loading...</div>
        <div class="card-subtitle">Network upload speed</div>
      </div>
      <div class="card">
        <div class="card-title"><i class="fas fa-plug"></i> Active Connections</div>
        <div class="card-value loading" id="activeConnections">Loading...</div>
        <div class="card-subtitle">Current open connections</div>
      </div>
      <div class="card">
        <div class="card-title"><i class="fas fa-tachometer-alt"></i> Average Latency</div>
        <div class="card-value loading" id="averageLatency">Loading...</div>
        <div class="card-subtitle">Network response time</div>
      </div>
      <div class="card">
        <div class="card-title"><i class="fas fa-exclamation-triangle"></i> Packet Loss</div>
        <div class="card-value loading" id="packetLoss">Loading...</div>
        <div class="card-subtitle" id="packetLossStatus">Waiting for data...</div>
      </div>
      <div class="card">
        <div class="card-title"><i class="fas fa-clock"></i> Last Updated</div>
        <div class="card-value loading" id="lastUpdated">Loading...</div>
        <div class="card-subtitle">Auto-updates every 5 seconds</div>
      </div>
    </div>

    <!-- Charts section -->
    <div class="chart-container">
      <div class="chart-card">
        <div class="chart-title">
          <span><i class="fas fa-chart-line"></i> Network Traffic</span>
          <div class="actions">
            <button id="refreshTrafficChart" title="Refresh"><i class="fas fa-sync-alt"></i></button>
            <button id="downloadTrafficChart" title="Download"><i class="fas fa-download"></i></button>
            <button id="expandTrafficChart" title="Expand"><i class="fas fa-expand"></i></button>
          </div>
        </div>
        <div class="chart-wrapper">
          <div id="trafficChartLoading" class="chart-loading">
            <div class="chart-spinner"></div>
            <span>Loading chart data...</span>
          </div>
          <canvas id="trafficChart"></canvas>
        </div>
      </div>
      <div class="chart-card">
        <div class="chart-title">
          <span><i class="fas fa-tachometer-alt"></i> Latency & Packet Loss</span>
          <div class="actions">
            <button id="refreshLatencyChart" title="Refresh"><i class="fas fa-sync-alt"></i></button>
            <button id="downloadLatencyChart" title="Download"><i class="fas fa-download"></i></button>
            <button id="expandLatencyChart" title="Expand"><i class="fas fa-expand"></i></button>
          </div>
        </div>
        <div class="chart-wrapper">
          <div id="latencyChartLoading" class="chart-loading">
            <div class="chart-spinner"></div>
            <span>Loading chart data...</span>
          </div>
          <canvas id="latencyChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Network Topology Section -->
    <div class="topology-section">
      <div class="section-header">
        <h2><i class="fas fa-project-diagram"></i> Network Topology</h2>
        <div class="actions">
          <button id="refreshTopology" title="Refresh"><i class="fas fa-sync-alt"></i></button>
          <button id="expandTopology" title="Expand"><i class="fas fa-expand"></i></button>
        </div>
      </div>
      <div class="topology-container">
        <div id="topologyChart" class="topology-chart"></div>
        <div class="topology-legend">
          <div class="legend-item">
            <div class="legend-color" style="background-color: #6366f1;"></div>
            <span>Your Device</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #10b981;"></div>
            <span>Active Connection</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #f59e0b;"></div>
            <span>High Traffic</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #ef4444;"></div>
            <span>Potential Issue</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer">
      <div class="footer-content">
        <div class="footer-section">
          <h3><i class="fas fa-network-wired"></i> Network Monitor</h3>
          <p>Real-time network monitoring system</p>
          <p>Version 1.0.0 | <span id="connectionStatus" class="badge badge-success">Connected</span></p>
        </div>

        <div class="footer-section">
          <h3><i class="fas fa-server"></i> API Status</h3>
          <p id="apiStatus">Connected to backend API</p>
          <p id="lastUpdatedTime">Last updated: -</p>
        </div>

        <div class="footer-section">
          <h3><i class="fas fa-cog"></i> Settings</h3>
          <button id="darkModeButton" class="theme-button">
            <i class="fas fa-moon"></i> Dark Mode
          </button>
          <button id="refreshAllButton" class="refresh-button">
            <i class="fas fa-sync-alt"></i> Refresh All Data
          </button>
        </div>
      </div>

      <div class="footer-bottom">
        <p>&copy; <span id="currentYear"></span> Network Monitoring System | All Rights Reserved</p>
      </div>
    </div>

    <div id="status" style="display: none;"></div>
  </div>

  <script>
    // DOM elements
    const incomingTrafficElement = document.getElementById('incomingTraffic');
    const outgoingTrafficElement = document.getElementById('outgoingTraffic');
    const activeConnectionsElement = document.getElementById('activeConnections');
    const averageLatencyElement = document.getElementById('averageLatency');
    const packetLossElement = document.getElementById('packetLoss');
    const packetLossStatusElement = document.getElementById('packetLossStatus');
    const lastUpdatedElement = document.getElementById('lastUpdated');
    const statusElement = document.getElementById('status');
    const statusMessageElement = document.getElementById('statusMessage');
    const statusTextElement = document.getElementById('statusText');
    const fetchDataButton = document.getElementById('fetchData');
    const timeRangeSelect = document.getElementById('timeRange');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const darkModeButton = document.getElementById('darkModeButton');
    const refreshAllButton = document.getElementById('refreshAllButton');
    const dismissStatusButton = document.getElementById('dismissStatus');
    const connectionStatusElement = document.getElementById('connectionStatus');
    const apiStatusElement = document.getElementById('apiStatus');
    const lastUpdatedTimeElement = document.getElementById('lastUpdatedTime');
    const currentYearElement = document.getElementById('currentYear');
    const refreshIndicatorElement = document.getElementById('refreshIndicator');

    // Chart references
    let trafficChart = null;
    let latencyChart = null;

    // Chart data
    let historicalData = [];

    // Dark mode state
    let darkMode = false;

    // API URL
    const API_URL = '/api';

    // Set current year in footer
    currentYearElement.textContent = new Date().getFullYear();

    // Initialize dashboard
    function initDashboard() {
      console.log('Initializing dashboard...');

      // Load dark mode preference from localStorage
      const savedDarkMode = localStorage.getItem('darkMode');
      if (savedDarkMode === 'true') {
        darkMode = true;
        document.body.classList.add('dark-mode');
        updateDarkModeButtons();
      }

      // Set up event listeners
      setupEventListeners();

      // Initialize with sample data first to ensure charts are visible
      historicalData = createSampleData();
      updateCharts();

      // Then fetch real data
      console.log('Fetching initial data...');
      fetchCurrentData()
        .then(() => {
          console.log('Current data fetched successfully');
          return fetchHistoricalData();
        })
        .then(() => {
          console.log('Historical data fetched successfully');
        })
        .catch(error => {
          console.error('Error during initialization:', error);
          showStatusMessage('Error initializing dashboard. Using sample data.', 'warning');
          // Ensure we have sample data if fetching fails
          if (!historicalData || historicalData.length === 0) {
            historicalData = createSampleData();
            updateCharts();
          }
        });
    }

    // Set up event listeners
    function setupEventListeners() {
      // Fetch data button
      fetchDataButton.addEventListener('click', () => {
        fetchCurrentData();
        fetchHistoricalData();
        showStatusMessage('Refreshing data...', 'info');
      });

      // Export data button
      document.getElementById('exportDataBtn').addEventListener('click', () => {
        exportData();
      });

      // Time range select
      timeRangeSelect.addEventListener('change', () => {
        fetchHistoricalData();
        showStatusMessage(`Fetching data for the last ${timeRangeSelect.value}...`, 'info');
      });

      // Dark mode toggle
      darkModeToggle.addEventListener('click', toggleDarkMode);
      darkModeButton.addEventListener('click', toggleDarkMode);

      // Refresh all button
      refreshAllButton.addEventListener('click', () => {
        fetchCurrentData();
        fetchHistoricalData();
        showStatusMessage('Refreshing all data...', 'info');
      });

      // Dismiss status button
      dismissStatusButton.addEventListener('click', hideStatusMessage);

      // Chart refresh buttons
      document.getElementById('refreshTrafficChart').addEventListener('click', () => {
        fetchHistoricalData();
        showStatusMessage('Refreshing traffic chart...', 'info');
      });

      document.getElementById('refreshLatencyChart').addEventListener('click', () => {
        fetchHistoricalData();
        showStatusMessage('Refreshing latency chart...', 'info');
      });

      // Chart download buttons
      document.getElementById('downloadTrafficChart').addEventListener('click', () => {
        downloadChart('trafficChart', 'network-traffic.png');
      });

      document.getElementById('downloadLatencyChart').addEventListener('click', () => {
        downloadChart('latencyChart', 'latency-packet-loss.png');
      });

      // Chart expand buttons
      document.getElementById('expandTrafficChart').addEventListener('click', () => {
        toggleChartFullscreen('trafficChart');
      });

      document.getElementById('expandLatencyChart').addEventListener('click', () => {
        toggleChartFullscreen('latencyChart');
      });
    }

    // Toggle dark mode
    function toggleDarkMode() {
      darkMode = !darkMode;

      if (darkMode) {
        document.body.classList.add('dark-mode');
      } else {
        document.body.classList.remove('dark-mode');
      }

      // Update buttons
      updateDarkModeButtons();

      // Update charts
      updateCharts();

      // Save preference to localStorage
      localStorage.setItem('darkMode', darkMode ? 'true' : 'false');
    }

    // Update dark mode buttons
    function updateDarkModeButtons() {
      if (darkMode) {
        darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        darkModeButton.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
      } else {
        darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        darkModeButton.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
      }
    }

    // Show status message
    function showStatusMessage(message, type = 'info') {
      statusTextElement.textContent = message;
      statusMessageElement.className = 'status-message';

      if (type === 'success') {
        statusMessageElement.classList.add('success');
      } else if (type === 'error') {
        statusMessageElement.classList.add('error');
      }

      statusMessageElement.style.display = 'flex';

      // Auto-hide after 5 seconds
      setTimeout(hideStatusMessage, 5000);
    }

    // Hide status message
    function hideStatusMessage() {
      statusMessageElement.style.display = 'none';
    }

    // Fetch current metrics
    async function fetchCurrentData() {
      try {
        // Show refresh indicator
        refreshIndicatorElement.classList.add('active');

        const response = await fetch(`${API_URL}/network/metrics/current`);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Current metrics:', data);

        // Update UI
        updateMetricsCards(data);

        // Update connection status
        updateConnectionStatus(true);

        // Update last updated time
        const now = new Date();
        lastUpdatedTimeElement.textContent = `Last updated: ${now.toLocaleTimeString()}`;

        return data;
      } catch (error) {
        console.error('Error fetching current data:', error);
        showStatusMessage(`Error fetching current data: ${error.message}`, 'error');
        updateConnectionStatus(false);
        return null;
      } finally {
        // Hide refresh indicator after a short delay for better UX
        setTimeout(() => {
          refreshIndicatorElement.classList.remove('active');
        }, 500);
      }
    }

    // Fetch historical metrics
    async function fetchHistoricalData() {
      try {
        // Show refresh indicator
        refreshIndicatorElement.classList.add('active');

        const timeRange = timeRangeSelect.value;
        console.log(`Fetching historical data for time range: ${timeRange}`);

        const response = await fetch(`${API_URL}/network/metrics/historical?time_range=${timeRange}`);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        let data;
        try {
          const text = await response.text();
          console.log('Raw response:', text);
          data = JSON.parse(text);
        } catch (parseError) {
          console.error('Error parsing JSON:', parseError);
          throw new Error(`Failed to parse response: ${parseError.message}`);
        }

        console.log('Historical metrics:', data);

        // Validate data
        if (!Array.isArray(data)) {
          console.warn('Historical data is not an array, converting to array');
          data = [data]; // Convert single object to array
        }

        if (data.length === 0) {
          console.warn('Historical data array is empty, using sample data');
          data = createSampleData();
        }

        // Store historical data
        historicalData = data;

        // Update charts
        updateCharts();

        return data;
      } catch (error) {
        console.error('Error fetching historical data:', error);
        showStatusMessage(`Error fetching historical data: ${error.message}. Using sample data.`, 'warning');

        // Use sample data if we don't have any data yet
        if (!historicalData || historicalData.length === 0) {
          historicalData = createSampleData();
        }

        // Update charts with whatever data we have
        updateCharts();

        return historicalData;
      } finally {
        // Hide refresh indicator after a short delay for better UX
        setTimeout(() => {
          refreshIndicatorElement.classList.remove('active');
        }, 500);
      }
    }

    // Update metrics cards
    function updateMetricsCards(data) {
      // Remove loading class from all cards
      document.querySelectorAll('.card-value.loading').forEach(el => {
        el.classList.remove('loading');
      });

      // Format incoming traffic with animation
      animateValue(incomingTrafficElement, parseFloat(incomingTrafficElement.textContent) || 0, data.incoming_traffic, 500, (value) => {
        return `${value.toFixed(2)} Mbps`;
      });

      // Format outgoing traffic with animation
      animateValue(outgoingTrafficElement, parseFloat(outgoingTrafficElement.textContent) || 0, data.outgoing_traffic, 500, (value) => {
        return `${value.toFixed(2)} Mbps`;
      });

      // Format active connections with animation
      animateValue(activeConnectionsElement, parseInt(activeConnectionsElement.textContent) || 0, data.active_connections, 500, (value) => {
        return Math.round(value).toLocaleString();
      });

      // Format average latency with animation
      animateValue(averageLatencyElement, parseFloat(averageLatencyElement.textContent) || 0, data.average_latency, 500, (value) => {
        return `${value.toFixed(1)} ms`;
      });

      // Format packet loss with animation
      const packetLoss = data.packet_loss || 0;
      animateValue(packetLossElement, parseFloat(packetLossElement.textContent) || 0, packetLoss, 500, (value) => {
        return `${value.toFixed(2)}%`;
      });

      // Update packet loss color and status
      if (packetLoss > 1) {
        packetLossElement.style.color = '#ef4444';
        packetLossStatusElement.textContent = 'Warning: High packet loss';
        packetLossStatusElement.style.color = '#ef4444';
      } else {
        packetLossElement.style.color = '#10b981';
        packetLossStatusElement.textContent = 'Normal packet loss';
        packetLossStatusElement.style.color = '#10b981';
      }

      // Update last updated time
      lastUpdatedElement.textContent = new Date(data.timestamp).toLocaleTimeString();
    }

    // Animate value change
    function animateValue(element, start, end, duration, formatter) {
      if (start === end) return;

      const startTime = performance.now();
      const updateValue = (timestamp) => {
        const elapsed = timestamp - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation
        const easeOutQuad = progress * (2 - progress);
        const currentValue = start + (end - start) * easeOutQuad;

        element.textContent = formatter(currentValue);

        if (progress < 1) {
          requestAnimationFrame(updateValue);
        }
      };

      requestAnimationFrame(updateValue);
    }

    // Update connection status
    function updateConnectionStatus(connected) {
      if (connected) {
        connectionStatusElement.textContent = 'Connected';
        connectionStatusElement.className = 'badge badge-success';
        apiStatusElement.textContent = `Connected to backend API at ${API_URL}`;
      } else {
        connectionStatusElement.textContent = 'Disconnected';
        connectionStatusElement.className = 'badge badge-error';
        apiStatusElement.textContent = `Failed to connect to backend API at ${API_URL}`;
      }
    }

    // Update charts
    function updateCharts() {
      console.log('Updating charts with data:', historicalData);

      // Check if we have data
      if (!historicalData || historicalData.length === 0) {
        console.warn('No historical data available for charts');
        showStatusMessage('No historical data available. Using sample data for visualization.', 'warning');

        // Create sample data for visualization
        historicalData = createSampleData();
      } else {
        console.log('Using real data for charts, data length:', historicalData.length);

        // Validate data format
        const isValidData = historicalData.every(item => {
          return item &&
                 typeof item.timestamp === 'string' &&
                 typeof item.incoming_traffic === 'number' &&
                 typeof item.outgoing_traffic === 'number' &&
                 typeof item.average_latency === 'number';
        });

        if (!isValidData) {
          console.warn('Data format is invalid, using sample data');
          historicalData = createSampleData();
        }
      }

      try {
        // Force chart recreation by destroying existing charts
        if (trafficChart) {
          trafficChart.destroy();
          trafficChart = null;
        }

        if (latencyChart) {
          latencyChart.destroy();
          latencyChart = null;
        }

        // Update charts
        updateTrafficChart();
        updateLatencyChart();
        console.log('Charts updated successfully');
      } catch (error) {
        console.error('Error updating charts:', error);
        showStatusMessage(`Error updating charts: ${error.message}. Using sample data.`, 'error');

        // Try again with sample data
        historicalData = createSampleData();

        // Force chart recreation
        if (trafficChart) {
          trafficChart.destroy();
          trafficChart = null;
        }

        if (latencyChart) {
          latencyChart.destroy();
          latencyChart = null;
        }

        updateTrafficChart();
        updateLatencyChart();
      }
    }

    // Create sample data for visualization when API data is not available
    function createSampleData() {
      console.log('Creating sample data');
      const sampleData = [];
      const now = new Date();

      // Create 10 data points, one for each minute in the past
      for (let i = 9; i >= 0; i--) {
        const timestamp = new Date(now);
        timestamp.setMinutes(now.getMinutes() - i);

        sampleData.push({
          timestamp: timestamp.toISOString(),
          incoming_traffic: Math.random() * 0.5 + 0.1, // Random value between 0.1 and 0.6
          outgoing_traffic: Math.random() * 0.4 + 0.05, // Random value between 0.05 and 0.45
          active_connections: Math.floor(Math.random() * 500) + 100, // Random value between 100 and 600
          average_latency: Math.random() * 50 + 10, // Random value between 10 and 60
          packet_loss: Math.random() * 1.5 // Random value between 0 and 1.5
        });
      }

      console.log('Sample data created:', sampleData);
      return sampleData;
    }

    // Update traffic chart
    function updateTrafficChart() {
      console.log('Updating traffic chart');
      const canvas = document.getElementById('trafficChart');
      const loadingElement = document.getElementById('trafficChartLoading');

      if (!canvas) {
        console.error('Traffic chart canvas not found');
        return;
      }

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2D context for traffic chart');
        return;
      }

      // Show loading indicator
      if (loadingElement) {
        loadingElement.classList.remove('hidden');
      }

      // Prepare data
      const labels = historicalData.map(entry => {
        const time = new Date(entry.timestamp);
        return `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
      });

      const incomingData = historicalData.map(entry => entry.incoming_traffic);
      const outgoingData = historicalData.map(entry => entry.outgoing_traffic);

      console.log('Chart data prepared:', { labels, incomingData, outgoingData });

      // Create or update chart
      if (trafficChart) {
        console.log('Updating existing traffic chart');
        // Update existing chart
        trafficChart.data.labels = labels;
        trafficChart.data.datasets[0].data = incomingData;
        trafficChart.data.datasets[1].data = outgoingData;
        trafficChart.update('none'); // Use 'none' for smoother updates

        // Hide loading indicator
        if (loadingElement) {
          loadingElement.classList.add('hidden');
        }
      } else {
        console.log('Creating new traffic chart');
        // Create new chart
        trafficChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Incoming Traffic (Mbps)',
                data: incomingData,
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.4,
                fill: true
              },
              {
                label: 'Outgoing Traffic (Mbps)',
                data: outgoingData,
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.4,
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 800,
              easing: 'easeOutQuart'
            },
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  usePointStyle: true,
                  padding: 15
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                padding: 10,
                cornerRadius: 4,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      label += context.parsed.y.toFixed(2) + ' Mbps';
                    }
                    return label;
                  }
                }
              }
            },
            scales: {
              x: {
                grid: {
                  display: false
                }
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Mbps',
                  font: {
                    weight: 'bold'
                  }
                },
                ticks: {
                  callback: function(value) {
                    return value.toFixed(2) + ' Mbps';
                  }
                }
              }
            }
          }
        });

        // Hide loading indicator
        if (loadingElement) {
          loadingElement.classList.add('hidden');
        }
      }
    }

    // Update latency chart
    function updateLatencyChart() {
      console.log('Updating latency chart');
      const canvas = document.getElementById('latencyChart');
      const loadingElement = document.getElementById('latencyChartLoading');

      if (!canvas) {
        console.error('Latency chart canvas not found');
        return;
      }

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2D context for latency chart');
        return;
      }

      // Show loading indicator
      if (loadingElement) {
        loadingElement.classList.remove('hidden');
      }

      // Prepare data
      const labels = historicalData.map(entry => {
        const time = new Date(entry.timestamp);
        return `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
      });

      const latencyData = historicalData.map(entry => entry.average_latency);
      const packetLossData = historicalData.map(entry => entry.packet_loss || 0);

      console.log('Latency chart data prepared:', { labels, latencyData, packetLossData });

      // Create or update chart
      if (latencyChart) {
        console.log('Updating existing latency chart');
        // Update existing chart
        latencyChart.data.labels = labels;
        latencyChart.data.datasets[0].data = latencyData;
        latencyChart.data.datasets[1].data = packetLossData;
        latencyChart.update('none'); // Use 'none' for smoother updates

        // Hide loading indicator
        if (loadingElement) {
          loadingElement.classList.add('hidden');
        }
      } else {
        console.log('Creating new latency chart');
        // Create chart
        latencyChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Latency (ms)',
                data: latencyData,
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.4,
                fill: true,
                yAxisID: 'y'
              },
              {
                label: 'Packet Loss (%)',
                data: packetLossData,
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.4,
                fill: true,
                yAxisID: 'y1'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 800,
              easing: 'easeOutQuart'
            },
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  usePointStyle: true,
                  padding: 15
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                padding: 10,
                cornerRadius: 4,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      if (context.datasetIndex === 0) {
                        label += context.parsed.y.toFixed(1) + ' ms';
                      } else {
                        label += context.parsed.y.toFixed(2) + '%';
                      }
                    }
                    return label;
                  }
                }
              }
            },
            scales: {
              x: {
                grid: {
                  display: false
                }
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Latency (ms)',
                  font: {
                    weight: 'bold'
                  }
                },
                position: 'left',
                ticks: {
                  callback: function(value) {
                    return value.toFixed(1) + ' ms';
                  }
                }
              },
              y1: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Packet Loss (%)',
                  font: {
                    weight: 'bold'
                  }
                },
                position: 'right',
                grid: {
                  drawOnChartArea: false,
                },
                ticks: {
                  callback: function(value) {
                    return value.toFixed(2) + '%';
                  }
                }
              }
            }
          }
        });

        // Hide loading indicator
        if (loadingElement) {
          loadingElement.classList.add('hidden');
        }
      }
    }

    // Download chart as image
    function downloadChart(chartId, filename) {
      try {
        const canvas = document.getElementById(chartId);
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png');
        link.click();
        showStatusMessage(`Downloaded ${filename} successfully!`, 'success');
      } catch (error) {
        console.error('Error downloading chart:', error);
        showStatusMessage(`Error downloading chart: ${error.message}`, 'error');
      }
    }

    // Toggle chart fullscreen
    function toggleChartFullscreen(chartId) {
      const chartWrapper = document.getElementById(chartId).closest('.chart-wrapper');
      const chartCard = chartWrapper.closest('.chart-card');

      if (chartCard.classList.contains('fullscreen')) {
        // Exit fullscreen
        chartCard.classList.remove('fullscreen');
        document.body.classList.remove('no-scroll');
        showStatusMessage('Exited fullscreen mode', 'info');
      } else {
        // Enter fullscreen
        chartCard.classList.add('fullscreen');
        document.body.classList.add('no-scroll');
        showStatusMessage('Entered fullscreen mode. Click again to exit.', 'info');
      }

      // Resize chart after transition
      setTimeout(() => {
        if (chartId === 'trafficChart' && trafficChart) {
          trafficChart.resize();
        } else if (chartId === 'latencyChart' && latencyChart) {
          latencyChart.resize();
        }
      }, 300);
    }

    // Export data as CSV
    function exportData() {
      try {
        // Create CSV content
        let csvContent = 'data:text/csv;charset=utf-8,';

        // Add headers
        csvContent += 'Timestamp,Incoming Traffic (Mbps),Outgoing Traffic (Mbps),Active Connections,Average Latency (ms),Packet Loss (%)\n';

        // Add data rows
        historicalData.forEach(entry => {
          const row = [
            new Date(entry.timestamp).toISOString(),
            entry.incoming_traffic.toFixed(2),
            entry.outgoing_traffic.toFixed(2),
            entry.active_connections,
            entry.average_latency.toFixed(1),
            (entry.packet_loss || 0).toFixed(2)
          ];
          csvContent += row.join(',') + '\n';
        });

        // Create download link
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', `network-data-${new Date().toISOString().slice(0, 10)}.csv`);
        document.body.appendChild(link);

        // Trigger download
        link.click();
        document.body.removeChild(link);

        showStatusMessage('Data exported successfully!', 'success');
      } catch (error) {
        console.error('Error exporting data:', error);
        showStatusMessage(`Error exporting data: ${error.message}`, 'error');
      }
    }

    // Create network topology visualization
    function createNetworkTopology() {
      console.log('Creating network topology visualization');

      // Get the container dimensions
      const container = document.getElementById('topologyChart');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Clear any existing SVG
      d3.select('#topologyChart svg').remove();

      // Create SVG element
      const svg = d3.select('#topologyChart')
        .append('svg')
        .attr('width', width)
        .attr('height', height);

      // Create sample network data
      const nodes = [];
      const links = [];

      // Add central node (your device)
      nodes.push({
        id: 'you',
        name: 'Your Device',
        type: 'central',
        connections: 0
      });

      // Add connected devices
      const numDevices = Math.floor(Math.random() * 5) + 5; // 5-10 devices

      for (let i = 0; i < numDevices; i++) {
        const deviceId = `device-${i}`;
        const connections = Math.floor(Math.random() * 3) + 1; // 1-3 connections
        const deviceType = Math.random() > 0.8 ? 'warning' : 'normal'; // 20% chance of warning

        nodes.push({
          id: deviceId,
          name: `Device ${i+1}`,
          type: deviceType,
          connections: connections
        });

        // Connect to central node
        links.push({
          source: 'you',
          target: deviceId,
          value: Math.random() * 10
        });

        // Connect some devices to each other
        if (i > 0 && Math.random() > 0.5) {
          const targetIndex = Math.floor(Math.random() * i);
          links.push({
            source: deviceId,
            target: `device-${targetIndex}`,
            value: Math.random() * 5
          });
        }
      }

      // Create force simulation
      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-200))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));

      // Create links
      const link = svg.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('stroke-width', d => Math.sqrt(d.value))
        .attr('stroke', '#ccc');

      // Create nodes
      const node = svg.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(nodes)
        .enter().append('g');

      // Add circles to nodes
      node.append('circle')
        .attr('r', d => d.type === 'central' ? 15 : 10)
        .attr('fill', d => {
          if (d.type === 'central') return '#6366f1'; // Primary color for your device
          if (d.type === 'warning') return '#f59e0b'; // Warning color
          return '#10b981'; // Normal color
        })
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      // Add labels to nodes
      node.append('text')
        .text(d => d.name)
        .attr('x', 15)
        .attr('y', 5)
        .style('font-size', '10px')
        .style('fill', 'var(--text-secondary)');

      // Add title for tooltip
      node.append('title')
        .text(d => `${d.name}\nConnections: ${d.connections}`);

      // Update positions on simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node
          .attr('transform', d => `translate(${d.x},${d.y})`);
      });

      // Drag functions
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }

    // Add event listeners for topology buttons
    document.getElementById('refreshTopology').addEventListener('click', () => {
      createNetworkTopology();
      showStatusMessage('Network topology refreshed', 'info');
    });

    document.getElementById('expandTopology').addEventListener('click', () => {
      const container = document.querySelector('.topology-container');
      if (container.classList.contains('expanded')) {
        container.classList.remove('expanded');
        document.getElementById('expandTopology').innerHTML = '<i class="fas fa-expand"></i>';
      } else {
        container.classList.add('expanded');
        document.getElementById('expandTopology').innerHTML = '<i class="fas fa-compress"></i>';
      }
    });

    // Fetch data every 5 seconds
    setInterval(() => {
      fetchCurrentData();
    }, 5000);

    // Initialize dashboard
    initDashboard();

    // Create network topology after a short delay
    setTimeout(createNetworkTopology, 1000);

    // Ensure charts are created even if everything else fails
    setTimeout(() => {
      if (!trafficChart || !latencyChart) {
        console.warn('Charts not created after initialization, forcing creation with sample data');
        historicalData = createSampleData();
        updateCharts();
      }
    }, 3000);
</body>
</html>
