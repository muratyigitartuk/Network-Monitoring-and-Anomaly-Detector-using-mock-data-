<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Monitor - Connected to Backend API</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- React and ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <!-- Modern Dashboard CSS -->
  <link rel="stylesheet" href="/static/dashboard-modern.css">

  <!-- Original inline styles (will be overridden by external CSS) -->
  <style>
    :root {
      --primary-color: #3b82f6;
      --secondary-color: #10b981;
      --accent-color: #8b5cf6;
      --background-color: #f5f5f5;
      --card-background: #ffffff;
      --text-primary: #333333;
      --text-secondary: #666666;
      --border-radius: 8px;
      --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-primary);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .header h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
    }

    .controls {
      display: flex;
      gap: 10px;
    }

    select, button {
      padding: 8px 12px;
      border-radius: var(--border-radius);
      border: 1px solid #ddd;
      background-color: white;
      font-size: 14px;
    }

    button {
      cursor: pointer;
      background-color: var(--primary-color);
      color: white;
      border: none;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #2563eb;
    }

    .card-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .card {
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .card-title {
      font-size: 16px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .card-value {
      font-size: 24px;
      font-weight: bold;
      color: var(--text-primary);
    }

    .blue { color: var(--primary-color); }
    .green { color: var(--secondary-color); }
    .purple { color: var(--accent-color); }

    .chart-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .chart-card {
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .chart-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: var(--text-primary);
    }

    .chart-wrapper {
      height: 300px;
      position: relative;
    }

    .data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
    }

    .data-table th, .data-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    .data-table th {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .data-table tbody tr:hover {
      background-color: #f9f9f9;
    }

    .footer {
      margin-top: 40px;
      text-align: center;
      color: var(--text-secondary);
      font-size: 14px;
    }

    /* Loading indicator */
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100%;
      position: fixed;
      top: 0;
      left: 0;
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 1000;
    }

    .loading-spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid var(--primary-color);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Error message */
    .error-message {
      background-color: #fee2e2;
      color: #b91c1c;
      padding: 15px;
      border-radius: var(--border-radius);
      margin-bottom: 20px;
      border: 1px solid #f87171;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .chart-container {
        grid-template-columns: 1fr;
      }

      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }

      .controls {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // React components
    function App() {
      console.log('App rendering');
      const [timeRange, setTimeRange] = React.useState('15m');
      const [darkMode, setDarkMode] = React.useState(false);
      const [currentMetrics, setCurrentMetrics] = React.useState(null);
      const [historicalMetrics, setHistoricalMetrics] = React.useState([]);
      const [loading, setLoading] = React.useState(true);
      const [error, setError] = React.useState(null);

      // Effect for dark mode toggle
      React.useEffect(() => {
        // Apply dark mode class to body
        if (darkMode) {
          document.body.classList.add('dark-mode');
        } else {
          document.body.classList.remove('dark-mode');
        }

        // Store preference in localStorage
        localStorage.setItem('darkMode', darkMode ? 'true' : 'false');
      }, [darkMode]);

      // Load dark mode preference from localStorage on mount
      React.useEffect(() => {
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') {
          setDarkMode(true);
        }
      }, []);

      // Chart references
      const trafficChartRef = React.useRef(null);
      const latencyChartRef = React.useRef(null);
      const protocolChartRef = React.useRef(null);
      const portChartRef = React.useRef(null);

      // API URL - relative path to avoid CORS issues
      const API_URL = '/api';

      // Fetch current metrics from API
      const fetchCurrentMetrics = async () => {
        try {
          const response = await fetch(`${API_URL}/network/metrics/current`);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();
          console.log('Current metrics:', data);
          setCurrentMetrics(data);
          return data;
        } catch (error) {
          console.error('Error fetching current metrics:', error);
          setError(`Failed to fetch current metrics: ${error.message}`);
          // Return mock data as fallback
          return generateMockMetrics();
        }
      };

      // Fetch historical metrics from API
      const fetchHistoricalMetrics = async () => {
        try {
          const response = await fetch(`${API_URL}/network/metrics/historical?time_range=${timeRange}`);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();
          console.log('Historical metrics:', data);
          setHistoricalMetrics(data);
          return data;
        } catch (error) {
          console.error('Error fetching historical metrics:', error);
          setError(`Failed to fetch historical metrics: ${error.message}`);
          // Return mock data as fallback
          return generateMockHistoricalData();
        }
      };

      // Generate mock metrics as fallback
      const generateMockMetrics = () => {
        return {
          timestamp: new Date().toISOString(),
          incomingTraffic: 125.45,
          outgoingTraffic: 67.89,
          activeConnections: 42,
          packetLoss: 0.5,
          averageLatency: 23.7,
          protocols: {
            tcp: 75,
            udp: 20,
            icmp: 3,
            other: 2
          },
          topSourceIPs: [
            { ip: '192.168.1.5', count: 1245, bytes: 5678901 },
            { ip: '192.168.1.10', count: 987, bytes: 4567890 },
            { ip: '192.168.1.15', count: 654, bytes: 3456789 },
            { ip: '192.168.1.20', count: 321, bytes: 2345678 },
            { ip: '192.168.1.25', count: 123, bytes: 1234567 },
          ],
          topDestIPs: [
            { ip: '8.8.8.8', count: 2345, bytes: 9876543 },
            { ip: '1.1.1.1', count: 1987, bytes: 8765432 },
            { ip: '208.67.222.222', count: 1654, bytes: 7654321 },
            { ip: '8.8.4.4', count: 1321, bytes: 6543210 },
            { ip: '9.9.9.9', count: 1123, bytes: 5432109 },
          ],
          portTraffic: [
            { port: 80, bytes: 7890123 },
            { port: 443, bytes: 6789012 },
            { port: 53, bytes: 5678901 },
            { port: 22, bytes: 4567890 },
            { port: 3389, bytes: 3456789 },
          ]
        };
      };

      // Generate mock historical data as fallback
      const generateMockHistoricalData = () => {
        const data = [];
        const now = new Date();

        for (let i = 0; i < 24; i++) {
          const timestamp = new Date(now.getTime() - (23 - i) * 15 * 60 * 1000);
          data.push({
            timestamp: timestamp.toISOString(),
            incomingTraffic: 50 + Math.random() * 100,
            outgoingTraffic: 30 + Math.random() * 70,
            activeConnections: Math.floor(20 + Math.random() * 50),
            packetLoss: Math.random() * 2,
            averageLatency: 10 + Math.random() * 30,
            protocols: {
              tcp: 75,
              udp: 20,
              icmp: 3,
              other: 2
            },
            topSourceIPs: [],
            topDestIPs: [],
            portTraffic: []
          });
        }

        return data;
      };

      // Initial data fetch
      React.useEffect(() => {
        const fetchInitialData = async () => {
          setLoading(true);
          try {
            // Fetch historical data first
            const historicalData = await fetchHistoricalMetrics();

            // If we have historical data, use the latest entry as current metrics
            if (historicalData && historicalData.length > 0) {
              setCurrentMetrics(historicalData[historicalData.length - 1]);
            } else {
              // Otherwise fetch current metrics
              await fetchCurrentMetrics();
            }
          } catch (error) {
            console.error('Error during initial data fetch:', error);
            setError(`Failed to fetch initial data: ${error.message}`);
          } finally {
            setLoading(false);
          }
        };

        fetchInitialData();
      }, []);

      // Fetch historical metrics when time range changes
      React.useEffect(() => {
        fetchHistoricalMetrics();
      }, [timeRange]);

      // Set up polling interval for real-time updates
      React.useEffect(() => {
        const interval = setInterval(() => {
          fetchCurrentMetrics();
        }, 5000);

        return () => clearInterval(interval);
      }, []);

      // Initialize and update charts
      React.useEffect(() => {
        if (!historicalMetrics || historicalMetrics.length === 0) return;

        // Traffic Chart
        if (trafficChartRef.current) {
          const ctx = trafficChartRef.current.getContext('2d');

          if (trafficChartRef.current.chart) {
            trafficChartRef.current.chart.destroy();
          }

          const labels = historicalMetrics.map(entry => {
            const time = new Date(entry.timestamp);
            return `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
          });

          trafficChartRef.current.chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Incoming Traffic (Mbps)',
                  data: historicalMetrics.map(entry => entry.incomingTraffic),
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  tension: 0.4,
                  fill: true
                },
                {
                  label: 'Outgoing Traffic (Mbps)',
                  data: historicalMetrics.map(entry => entry.outgoingTraffic),
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  tension: 0.4,
                  fill: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'top',
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Mbps'
                  }
                }
              }
            }
          });
        }

        // Latency Chart
        if (latencyChartRef.current) {
          const ctx = latencyChartRef.current.getContext('2d');

          if (latencyChartRef.current.chart) {
            latencyChartRef.current.chart.destroy();
          }

          const labels = historicalMetrics.map(entry => {
            const time = new Date(entry.timestamp);
            return `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
          });

          latencyChartRef.current.chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Latency (ms)',
                  data: historicalMetrics.map(entry => entry.averageLatency),
                  borderColor: '#8b5cf6',
                  backgroundColor: 'rgba(139, 92, 246, 0.1)',
                  tension: 0.4,
                  fill: true,
                  yAxisID: 'y'
                },
                {
                  label: 'Packet Loss (%)',
                  data: historicalMetrics.map(entry => entry.packetLoss),
                  borderColor: '#ef4444',
                  backgroundColor: 'rgba(239, 68, 68, 0.1)',
                  tension: 0.4,
                  fill: true,
                  yAxisID: 'y1'
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'top',
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Latency (ms)'
                  },
                  position: 'left',
                },
                y1: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Packet Loss (%)'
                  },
                  position: 'right',
                  grid: {
                    drawOnChartArea: false,
                  },
                }
              }
            }
          });
        }

        // Protocol Chart (uses current metrics)
        if (protocolChartRef.current && currentMetrics) {
          const ctx = protocolChartRef.current.getContext('2d');

          if (protocolChartRef.current.chart) {
            protocolChartRef.current.chart.destroy();
          }

          const protocols = currentMetrics.protocols || { tcp: 75, udp: 20, icmp: 3, other: 2 };

          protocolChartRef.current.chart = new Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: Object.keys(protocols).map(key => key.toUpperCase()),
              datasets: [
                {
                  data: Object.values(protocols),
                  backgroundColor: [
                    '#3b82f6',
                    '#10b981',
                    '#8b5cf6',
                    '#f59e0b'
                  ],
                  borderWidth: 1
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'right',
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const label = context.label || '';
                      const value = context.raw || 0;
                      const total = context.dataset.data.reduce((a, b) => a + b, 0);
                      const percentage = Math.round((value / total) * 100);
                      return `${label}: ${percentage}%`;
                    }
                  }
                }
              }
            }
          });
        }

        // Port Traffic Chart (uses current metrics)
        if (portChartRef.current && currentMetrics && currentMetrics.portTraffic) {
          const ctx = portChartRef.current.getContext('2d');

          if (portChartRef.current.chart) {
            portChartRef.current.chart.destroy();
          }

          portChartRef.current.chart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: currentMetrics.portTraffic.map(item => `Port ${item.port}`),
              datasets: [
                {
                  label: 'Traffic (bytes)',
                  data: currentMetrics.portTraffic.map(item => item.bytes),
                  backgroundColor: [
                    '#3b82f6',
                    '#10b981',
                    '#8b5cf6',
                    '#f59e0b',
                    '#ef4444'
                  ],
                  borderWidth: 1
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const value = context.raw;
                      // Format bytes to appropriate unit
                      if (value >= 1000000000) {
                        return `${(value / 1000000000).toFixed(2)} GB`;
                      } else if (value >= 1000000) {
                        return `${(value / 1000000).toFixed(2)} MB`;
                      } else if (value >= 1000) {
                        return `${(value / 1000).toFixed(2)} KB`;
                      } else {
                        return `${value} bytes`;
                      }
                    }
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: {
                    callback: function(value) {
                      if (value >= 1000000000) {
                        return `${(value / 1000000000).toFixed(1)} GB`;
                      } else if (value >= 1000000) {
                        return `${(value / 1000000).toFixed(1)} MB`;
                      } else if (value >= 1000) {
                        return `${(value / 1000).toFixed(1)} KB`;
                      } else {
                        return `${value} B`;
                      }
                    }
                  }
                }
              }
            }
          });
        }
      }, [historicalMetrics, currentMetrics]);

      // Format bytes to human-readable format
      const formatBytes = (bytes) => {
        if (bytes >= 1000000000) {
          return `${(bytes / 1000000000).toFixed(2)} GB`;
        } else if (bytes >= 1000000) {
          return `${(bytes / 1000000).toFixed(2)} MB`;
        } else if (bytes >= 1000) {
          return `${(bytes / 1000).toFixed(2)} KB`;
        } else {
          return `${bytes} bytes`;
        }
      };

      // Format timestamp
      const formatTimestamp = (timestamp) => {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleTimeString();
      };

      // If loading, show loading spinner
      if (loading) {
        return (
          <div className="loading">
            <div className="loading-spinner"></div>
          </div>
        );
      }

      // If no current metrics, show error
      if (!currentMetrics) {
        return (
          <div className="container">
            <div className="error-message">
              <h2>Error Loading Data</h2>
              <p>Could not load network metrics. Please check your connection to the backend API.</p>
              <button onClick={() => window.location.reload()}>Retry</button>
            </div>
          </div>
        );
      }

      return (
        <div className="container">
          {error && (
            <div className="error-message">
              <p>{error}</p>
              <button onClick={() => setError(null)}>Dismiss</button>
            </div>
          )}

          <div className="header">
            <h1><i className="fas fa-network-wired"></i> Network Monitor Dashboard</h1>
            <div className="controls">
              <select value={timeRange} onChange={(e) => setTimeRange(e.target.value)}>
                <option value="5m">Last 5 minutes</option>
                <option value="15m">Last 15 minutes</option>
                <option value="30m">Last 30 minutes</option>
                <option value="1h">Last hour</option>
                <option value="6h">Last 6 hours</option>
                <option value="24h">Last 24 hours</option>
              </select>
              <button onClick={() => alert('Data export functionality would go here')}>
                <i className="fas fa-download"></i> Export Data
              </button>
              <button className="theme-toggle" onClick={() => setDarkMode(!darkMode)}>
                {darkMode ? <i className="fas fa-sun"></i> : <i className="fas fa-moon"></i>}
              </button>
            </div>
          </div>

          <div className="card-container">
            <div className="card">
              <div className="card-title"><i className="fas fa-arrow-down"></i> Incoming Traffic</div>
              <div className="card-value blue">{currentMetrics.incomingTraffic.toFixed(2)} Mbps</div>
              <div className="card-subtitle">Network download speed</div>
            </div>
            <div className="card">
              <div className="card-title"><i className="fas fa-arrow-up"></i> Outgoing Traffic</div>
              <div className="card-value green">{currentMetrics.outgoingTraffic.toFixed(2)} Mbps</div>
              <div className="card-subtitle">Network upload speed</div>
            </div>
            <div className="card">
              <div className="card-title"><i className="fas fa-plug"></i> Active Connections</div>
              <div className="card-value purple">{currentMetrics.activeConnections}</div>
              <div className="card-subtitle">Current open connections</div>
            </div>
            <div className="card">
              <div className="card-title"><i className="fas fa-tachometer-alt"></i> Average Latency</div>
              <div className="card-value blue">{currentMetrics.averageLatency.toFixed(1)} ms</div>
              <div className="card-subtitle">Network response time</div>
            </div>
            <div className="card">
              <div className="card-title"><i className="fas fa-exclamation-triangle"></i> Packet Loss</div>
              <div className="card-value" style={{ color: currentMetrics.packetLoss > 1 ? '#ef4444' : '#10b981' }}>
                {currentMetrics.packetLoss.toFixed(2)}%
              </div>
              <div className="card-subtitle">{currentMetrics.packetLoss > 1 ? 'Warning: High packet loss' : 'Normal packet loss'}</div>
            </div>
            <div className="card">
              <div className="card-title"><i className="fas fa-clock"></i> Last Updated</div>
              <div className="card-value" style={{ fontSize: '16px' }}>
                {formatTimestamp(currentMetrics.timestamp)}
              </div>
              <div className="card-subtitle">Auto-updates every 5 seconds</div>
            </div>
          </div>

          <div className="chart-container">
            <div className="chart-card">
              <div className="chart-title">
                <span><i className="fas fa-chart-line"></i> Network Traffic</span>
                <div className="actions">
                  <button title="Refresh"><i className="fas fa-sync-alt"></i></button>
                  <button title="Download"><i className="fas fa-download"></i></button>
                  <button title="Expand"><i className="fas fa-expand"></i></button>
                </div>
              </div>
              <div className="chart-wrapper">
                <canvas ref={trafficChartRef}></canvas>
              </div>
            </div>
            <div className="chart-card">
              <div className="chart-title">
                <span><i className="fas fa-tachometer-alt"></i> Latency & Packet Loss</span>
                <div className="actions">
                  <button title="Refresh"><i className="fas fa-sync-alt"></i></button>
                  <button title="Download"><i className="fas fa-download"></i></button>
                  <button title="Expand"><i className="fas fa-expand"></i></button>
                </div>
              </div>
              <div className="chart-wrapper">
                <canvas ref={latencyChartRef}></canvas>
              </div>
            </div>
          </div>

          <div className="chart-container">
            <div className="chart-card">
              <div className="chart-title">
                <span><i className="fas fa-chart-pie"></i> Protocol Distribution</span>
                <div className="actions">
                  <button title="Refresh"><i className="fas fa-sync-alt"></i></button>
                  <button title="Download"><i className="fas fa-download"></i></button>
                  <button title="Expand"><i className="fas fa-expand"></i></button>
                </div>
              </div>
              <div className="chart-wrapper">
                <canvas ref={protocolChartRef}></canvas>
              </div>
            </div>
            <div className="chart-card">
              <div className="chart-title">
                <span><i className="fas fa-server"></i> Top Port Traffic</span>
                <div className="actions">
                  <button title="Refresh"><i className="fas fa-sync-alt"></i></button>
                  <button title="Download"><i className="fas fa-download"></i></button>
                  <button title="Expand"><i className="fas fa-expand"></i></button>
                </div>
              </div>
              <div className="chart-wrapper">
                <canvas ref={portChartRef}></canvas>
              </div>
            </div>
          </div>

          {currentMetrics.topSourceIPs && currentMetrics.topDestIPs && (
            <div className="data-grid">
              <div className="chart-card">
                <div className="chart-title">
                  <span><i className="fas fa-laptop"></i> Top Source IPs</span>
                  <div className="actions">
                    <button title="Refresh"><i className="fas fa-sync-alt"></i></button>
                    <button title="Download"><i className="fas fa-download"></i></button>
                  </div>
                </div>
                <table className="data-table">
                  <thead>
                    <tr>
                      <th>IP Address</th>
                      <th>Count</th>
                      <th>Traffic</th>
                    </tr>
                  </thead>
                  <tbody>
                    {currentMetrics.topSourceIPs.map((item, index) => (
                      <tr key={index}>
                        <td>{item.ip}</td>
                        <td>{item.count.toLocaleString()}</td>
                        <td>{formatBytes(item.bytes)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="chart-card">
                <div className="chart-title">
                  <span><i className="fas fa-globe"></i> Top Destination IPs</span>
                  <div className="actions">
                    <button title="Refresh"><i className="fas fa-sync-alt"></i></button>
                    <button title="Download"><i className="fas fa-download"></i></button>
                  </div>
                </div>
                <table className="data-table">
                  <thead>
                    <tr>
                      <th>IP Address</th>
                      <th>Count</th>
                      <th>Traffic</th>
                    </tr>
                  </thead>
                  <tbody>
                    {currentMetrics.topDestIPs.map((item, index) => (
                      <tr key={index}>
                        <td>{item.ip}</td>
                        <td>{item.count.toLocaleString()}</td>
                        <td>{formatBytes(item.bytes)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          <div className="footer">
            <div className="footer-content">
              <div className="footer-section">
                <h3><i className="fas fa-network-wired"></i> Network Anomaly Monitor</h3>
                <p>Real-time network monitoring and anomaly detection system</p>
                <p>Version 1.0.0 | <span className="badge badge-success">Connected</span></p>
              </div>

              <div className="footer-section">
                <h3><i className="fas fa-server"></i> API Status</h3>
                <p>Connected to backend API at {API_URL}</p>
                <p>Last updated: {new Date().toLocaleTimeString()}</p>
              </div>

              <div className="footer-section">
                <h3><i className="fas fa-cog"></i> Settings</h3>
                <button onClick={() => setDarkMode(!darkMode)} className="theme-button">
                  <i className={darkMode ? "fas fa-sun" : "fas fa-moon"}></i> {darkMode ? "Light Mode" : "Dark Mode"}
                </button>
                <button className="refresh-button">
                  <i className="fas fa-sync-alt"></i> Refresh Data
                </button>
              </div>
            </div>

            <div className="footer-bottom">
              <p>&copy; {new Date().getFullYear()} Network Monitoring System | All Rights Reserved</p>
            </div>
          </div>
        </div>
      );
    }

    // Render the App
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
